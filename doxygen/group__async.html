<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libafdt: Asynchronous Interface (libevent-based)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libafdt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Asynchronous Interface (libevent-based)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga938a755901d7bcaa6a2ddb2a28043b67"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga938a755901d7bcaa6a2ddb2a28043b67">afdt_request_handler_t</a> )(const uint8_t *request, uint32_t request_length, uint8_t *response, uint32_t *response_length, void *userdata)</td></tr>
<tr class="memdesc:ga938a755901d7bcaa6a2ddb2a28043b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for processing an AFDT request.  <a href="#ga938a755901d7bcaa6a2ddb2a28043b67">More...</a><br/></td></tr>
<tr class="separator:ga938a755901d7bcaa6a2ddb2a28043b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c238447afad6a19e62fe9c487f9cd6c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga3c238447afad6a19e62fe9c487f9cd6c">afdt_response_handler_t</a> )(const uint8_t *response, uint32_t response_length, int received_fd, void *userdata)</td></tr>
<tr class="memdesc:ga3c238447afad6a19e62fe9c487f9cd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for processing an AFDT response.  <a href="#ga3c238447afad6a19e62fe9c487f9cd6c">More...</a><br/></td></tr>
<tr class="separator:ga3c238447afad6a19e62fe9c487f9cd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f75a0754867bdf0265bb89579ada3e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#gac0f75a0754867bdf0265bb89579ada3e">afdt_post_handler_t</a> )(const uint8_t *request, uint32_t request_length, const uint8_t *response, uint32_t response_length, int sent_fd, void *userdata)</td></tr>
<tr class="memdesc:gac0f75a0754867bdf0265bb89579ada3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for after a response is sent.  <a href="#gac0f75a0754867bdf0265bb89579ada3e">More...</a><br/></td></tr>
<tr class="separator:gac0f75a0754867bdf0265bb89579ada3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb042e1c21b2838bc50ff0506c76a174"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#gacb042e1c21b2838bc50ff0506c76a174">afdt_error_handler_t</a> )(const struct <a class="el" href="structafdt__error__t.html">afdt_error_t</a> *err, void *userdata)</td></tr>
<tr class="memdesc:gacb042e1c21b2838bc50ff0506c76a174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for processing errors during AFDT operations.  <a href="#gacb042e1c21b2838bc50ff0506c76a174">More...</a><br/></td></tr>
<tr class="separator:gacb042e1c21b2838bc50ff0506c76a174"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga97feec482041f32b9115b4d3b4a3b27d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97feec482041f32b9115b4d3b4a3b27d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga97feec482041f32b9115b4d3b4a3b27d">afdt_no_post</a> (const uint8_t *request, uint32_t request_length, const uint8_t *response, uint32_t response_length, int sent_fd, void *userdata)</td></tr>
<tr class="memdesc:ga97feec482041f32b9115b4d3b4a3b27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op function that can be used as a post_handler. <br/></td></tr>
<tr class="separator:ga97feec482041f32b9115b4d3b4a3b27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22126951b8432bb549d6fdb7eefd12d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga22126951b8432bb549d6fdb7eefd12d3">afdt_create_server</a> (const char *fname, struct event_base *eb, <a class="el" href="group__async.html#ga938a755901d7bcaa6a2ddb2a28043b67">afdt_request_handler_t</a> request_handler, <a class="el" href="group__async.html#gac0f75a0754867bdf0265bb89579ada3e">afdt_post_handler_t</a> post_handler, <a class="el" href="group__async.html#gacb042e1c21b2838bc50ff0506c76a174">afdt_error_handler_t</a> error_handler, void **out_close_handle, void *userdata)</td></tr>
<tr class="memdesc:ga22126951b8432bb549d6fdb7eefd12d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a server to make file descriptors available.  <a href="#ga22126951b8432bb549d6fdb7eefd12d3">More...</a><br/></td></tr>
<tr class="separator:ga22126951b8432bb549d6fdb7eefd12d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdb2b5e05d4b7c79c4071e9e9a3f721"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga4fdb2b5e05d4b7c79c4071e9e9a3f721">afdt_close_server</a> (void *close_handle)</td></tr>
<tr class="memdesc:ga4fdb2b5e05d4b7c79c4071e9e9a3f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down a server created by <code>afdt_create_server</code>.  <a href="#ga4fdb2b5e05d4b7c79c4071e9e9a3f721">More...</a><br/></td></tr>
<tr class="separator:ga4fdb2b5e05d4b7c79c4071e9e9a3f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc7eac44f4be4aa4e14a6864c4bcee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async.html#ga1dc7eac44f4be4aa4e14a6864c4bcee1">afdt_create_client</a> (const char *fname, struct event_base *eb, const uint8_t *request, uint32_t request_length, <a class="el" href="group__async.html#ga3c238447afad6a19e62fe9c487f9cd6c">afdt_response_handler_t</a> response_handler, <a class="el" href="group__async.html#gacb042e1c21b2838bc50ff0506c76a174">afdt_error_handler_t</a> error_handler, const struct timeval *timeout, void *userdata)</td></tr>
<tr class="memdesc:ga1dc7eac44f4be4aa4e14a6864c4bcee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a file descriptor from a server.  <a href="#ga1dc7eac44f4be4aa4e14a6864c4bcee1">More...</a><br/></td></tr>
<tr class="separator:ga1dc7eac44f4be4aa4e14a6864c4bcee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The asynchronous interface provides functions for setting up clients and servers that use event-driven I/O to avoid blocking a thread. libevent is used to make the interface work with many different event APIs.</p>
<p>The asynchronous interface is adds more restrictions than the low-level API. Interactions are always composed of two messages: a plain message from the client to the server (the request) followed by an fd message from the server to the client(the response). There is currently no support for a client sending a file descriptor to the server. (In most cases, it is not too hard to invert the "client" and "server" roles to get around this. The server is simply the program that listens on the Unix domain socket.)</p>
<p>Most functions in this interface report errors by calling an error callback and passing error information to it. errno will be set to an appropriate code, or 0 if no error code is applicable. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gacb042e1c21b2838bc50ff0506c76a174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* afdt_error_handler_t)(const struct <a class="el" href="structafdt__error__t.html">afdt_error_t</a> *err, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for processing errors during AFDT operations. </p>
<p>For example, a callback could log an error message, then try some other means of acquiring the resources it needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phase</td><td>AFDT phase during which the error occurred. </td></tr>
    <tr><td class="paramname">operation</td><td>Operation that resulted in the error. </td></tr>
    <tr><td class="paramname">message</td><td>Extra information message (often empty). </td></tr>
    <tr><td class="paramname">userdata</td><td>Extra parameter passed to <code>create_client</code> or <code>create_server</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0f75a0754867bdf0265bb89579ada3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* afdt_post_handler_t)(const uint8_t *request, uint32_t request_length, const uint8_t *response, uint32_t response_length, int sent_fd, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for after a response is sent. </p>
<p>For example, a callback could close <em>sent_fd</em> if the recipient is going to take over all operations.</p>
<p>The post handler is called before the server returns to the event loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Request buffer sent by the client. </td></tr>
    <tr><td class="paramname">request_length</td><td>Length of <em>request</em>. </td></tr>
    <tr><td class="paramname">response</td><td>Response buffer sent by the server. </td></tr>
    <tr><td class="paramname">response_length</td><td>Length of <em>response</em>. </td></tr>
    <tr><td class="paramname">received_fd</td><td>File descriptor sent (by <em>request_handler</em>). </td></tr>
    <tr><td class="paramname">userdata</td><td>Extra parameter passed to <code>create_server</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga938a755901d7bcaa6a2ddb2a28043b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* afdt_request_handler_t)(const uint8_t *request, uint32_t request_length, uint8_t *response, uint32_t *response_length, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for processing an AFDT request. </p>
<p>For example, a callback could check some authentication information in the request, look in the request for the name of some resource, then return the appropriate fd or send an error message in the response. Remember to set *<em>response_length</em> to 0 if you are sending an empty response.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Request buffer sent by the client. </td></tr>
    <tr><td class="paramname">request_length</td><td>Length of <em>request</em>. </td></tr>
    <tr><td class="paramname">response</td><td>Buffer into which to write the response. </td></tr>
    <tr><td class="paramname">response_length</td><td>IN/OUT: <em>response</em> buffer/content size. </td></tr>
    <tr><td class="paramname">userdata</td><td>Extra parameter passed to <code>create_server</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File descriptor to send, or &lt;0 for none. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c238447afad6a19e62fe9c487f9cd6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* afdt_response_handler_t)(const uint8_t *response, uint32_t response_length, int received_fd, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for processing an AFDT response. </p>
<p>For example, a callback could pass the file descriptor to <em>evhttp_accept_socket</em> and start serving requests, or send another request if the response indicates that the transfer was not authorized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">response</td><td>Response buffer sent by the server. </td></tr>
    <tr><td class="paramname">response_length</td><td>Length of <em>response</em>. </td></tr>
    <tr><td class="paramname">received_fd</td><td>File descriptor received, or &lt;0 for none. </td></tr>
    <tr><td class="paramname">userdata</td><td>Extra parameter passed to <code>create_client</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4fdb2b5e05d4b7c79c4071e9e9a3f721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int afdt_close_server </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>close_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down a server created by <code>afdt_create_server</code>. </p>
<p>Any client connections that have already been created will continue to exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">close_handle</td><td>Handle provided by <code>afdt_create_server</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 if successful, &lt;0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1dc7eac44f4be4aa4e14a6864c4bcee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int afdt_create_client </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_base *&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__async.html#ga3c238447afad6a19e62fe9c487f9cd6c">afdt_response_handler_t</a>&#160;</td>
          <td class="paramname"><em>response_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__async.html#gacb042e1c21b2838bc50ff0506c76a174">afdt_error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a file descriptor from a server. </p>
<p>Exactly one of <em>response_handler</em> and <em>error_handler</em> will be called, unless timeout is <code>NULL</code> and the server never responds.</p>
<dl class="section note"><dt>Note</dt><dd>This function currently does a blocking connect and send.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>File to connect PF_LOCAL socket to. </td></tr>
    <tr><td class="paramname">eb</td><td>struct event_base to manage this client. </td></tr>
    <tr><td class="paramname">request</td><td>Request buffer to send. </td></tr>
    <tr><td class="paramname">request_length</td><td>Length of <em>request</em>. </td></tr>
    <tr><td class="paramname">response_handler</td><td>Callback to handle response. </td></tr>
    <tr><td class="paramname">error_handler</td><td>Callback to handle errors. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout when waiting for response, or <code>NULL</code>. </td></tr>
    <tr><td class="paramname">userdata</td><td>Arbitrary value to pass to callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 if connection and request successful, &lt;0 on failure. <em>error_handler</em> will also be called on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22126951b8432bb549d6fdb7eefd12d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int afdt_create_server </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct event_base *&#160;</td>
          <td class="paramname"><em>eb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__async.html#ga938a755901d7bcaa6a2ddb2a28043b67">afdt_request_handler_t</a>&#160;</td>
          <td class="paramname"><em>request_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__async.html#gac0f75a0754867bdf0265bb89579ada3e">afdt_post_handler_t</a>&#160;</td>
          <td class="paramname"><em>post_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__async.html#gacb042e1c21b2838bc50ff0506c76a174">afdt_error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>out_close_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a server to make file descriptors available. </p>
<p><em>request_handler</em> and <em>error_handler</em> may both be called multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>File to bind PF_LOCAL socket to. Must not exist. </td></tr>
    <tr><td class="paramname">eb</td><td>struct event_base to manage this server. </td></tr>
    <tr><td class="paramname">request_handler</td><td>Callback to handle requests. </td></tr>
    <tr><td class="paramname">post_handler</td><td>Callback called after sending a response. </td></tr>
    <tr><td class="paramname">error_handler</td><td>Callback to handle errors. </td></tr>
    <tr><td class="paramname">out_close_handle</td><td>If non-<code>NULL</code>, set to a handle for <code>afdt_close_server</code>. </td></tr>
    <tr><td class="paramname">userdata</td><td>Arbitrary value to pass to callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 if successful, &lt;0 on failure. <em>error_handler</em> will also be called on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 29 2015 12:11:28 for libafdt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
